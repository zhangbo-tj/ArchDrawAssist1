#include "StdAfx.h"
#include "G3DDataType.h"

//////////////////////////////////////////////////////////////////////////
//@intro	Vertex默认构造函数
//////////////////////////////////////////////////////////////////////////
Vertex::Vertex(){
	mVx = mVy = mVz = 0.0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	初始化Vertex的值
//////////////////////////////////////////////////////////////////////////
void Vertex::Init(){
	mVx = mVy = mVz = 0.0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	构造函数
//@param	vx:Vertex的X坐标值
//@param	vy:Vertex的Y坐标值
//@param	vz:Vertex的Z坐标值
//////////////////////////////////////////////////////////////////////////
Vertex::Vertex(float vx,float vy,float vz){
	mVx = vx;
	mVy = vy;
	mVz = vz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	重载赋值运算符
//@param	v:用来赋值的Vertex
//////////////////////////////////////////////////////////////////////////
Vertex &Vertex::operator=(Vertex v){
	mVx = v.GetX();
	mVy = v.GetY();
	mVz = v.GetZ();
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//@intro	实现两个Vertex相加的操作
//@param	v:被加的Vertex
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Vertex Vertex::Add(Vertex v){
	return Vertex(mVx+v.GetX(), mVy+v.GetY(),mVz+v.GetZ());
}

//////////////////////////////////////////////////////////////////////////
//@intro	实现两个Vertex相减的操作
//@param	v:当前Vertex减去的Vertex
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Vertex Vertex::Minus(Vertex v){
	return Vertex(mVx-v.GetX(),mVy-v.GetY(),mVz-v.GetZ());
}

//////////////////////////////////////////////////////////////////////////
//@intro	实现对Vertex乘以实数的运算
//@param	d:乘以的倍数
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Vertex Vertex::Mul(float d){
	return Vertex(mVx*d, mVy*d, mVz*d);
}

//////////////////////////////////////////////////////////////////////////
//@intro	将当前Vertex转换为数组
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float* Vertex::ToFloat(){
	static float n[3] = {0};
	n[0] = mVx;n[1] = mVy;n[2] = mVz;
	return n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	当前Vertex点乘另外一个Vertex
//@param	v:被乘的Vertex
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float Vertex::Dot(Vertex v){
	return mVx* v.GetX()+mVy*v.GetY()+mVz*v.GetZ();
}

//////////////////////////////////////////////////////////////////////////
//@intro	实现当前Vertex叉乘另一个Vertex
//@param	v:叉乘的另外一个Vertex
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Vertex Vertex::Cross(Vertex v){
	float vx = mVy* v.GetZ()- mVz*v.GetY();
	float vy = mVz*v.GetX()- mVx*v.GetZ();
	float vz = mVx*v.GetY() - mVy*v.GetX();
	return Vertex(vx,vy,vz);
}

//////////////////////////////////////////////////////////////////////////
//@intro	对Vertex进行单位化
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Vertex::Normalize(){
	float length = sqrt(mVx*mVx+mVy*mVy+mVz*mVz);
	mVx = mVx/length;
	mVy = mVy/length; 
	mVz = mVz/length;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取当前Vertex的X坐标
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float Vertex::GetX(){
	return mVx;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取当前Vertex的Y坐标
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float Vertex::GetY(){
	return mVy;
}

/////////////////////////////////////////////////////////////////////////
//@intro	获取当前Vertex的Z坐标
//  [5/10/2016 zhangbo]
////////////////////////////////////////////////////////////////////////
float Vertex::GetZ(){
	return mVz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置当前顶点的X坐标
//@param	vx:新的X坐标
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Vertex::SetX(float vx){
	mVx = vx;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置当前顶点的Y坐标
//@param	vy:新的Y坐标
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Vertex::SetY(float vy){
	mVy = vy;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置当前定点的Z坐标
//@param	vz:新的Z坐标
//////////////////////////////////////////////////////////////////////////
void Vertex::SetZ(float vz){
	mVz = vz;
};

//////////////////////////////////////////////////////////////////////////
//@intro	用数组设置当前顶点的坐标
//////////////////////////////////////////////////////////////////////////
void Vertex::Set(float* v){
	mVx = v[0];
	mVy = v[1];
	mVz = v[2];
}


//////////////////////////////////////////////////////////////////////////
//@intro	设置当前顶点的坐标
//@param	vx,vy,vz:当前顶点新的X坐标、Y坐标和Z坐标值
//////////////////////////////////////////////////////////////////////////
void Vertex::Set(float vx, float vy, float vz){
	mVx = vx;
	mVy = vy;
	mVz = vz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置当前顶点的坐标
//@param	vx,vy,vz:当前顶点新的X坐标、Y坐标和Z坐标值
//////////////////////////////////////////////////////////////////////////
void Vertex::Set(double vx, double vy, double vz){
	mVx = vx;
	mVy = vy;
	mVz = vz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	默认构造函数
//////////////////////////////////////////////////////////////////////////
Point::Point(){
	mPx = mPy = mPz = trinum = 0;
	mNormal = Normal();
	mPrincipal1 = Normal();
	mPrincipal2 = Normal();
	index = 0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	构造函数
//@param	px:点的X坐标值
//@param	py:点的Y坐标值
//@param	pz:点的Z坐标值
//@param	num:点所在的三角面片索引
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Point::Point(float px,float py,float pz,int num){
	mPx = px;
	mPy = py;
	mPz= pz;
	trinum = num;
	mNormal = Normal();
	mPrincipal1 = Normal();
	mPrincipal2 = Normal();
	index = 0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	将点的坐标值转换为数组
//@return	坐标值转换后得到的数组
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float* Point::ToFloat(){
	static float n[3] = {0};
	n[0] = mPx;n[1] = mPy;n[2] = mPz;
	return n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取当前顶点的X坐标值
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float Point::GetX(){
	return mPx;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取当前顶点的Y坐标值
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float Point::GetY(){
	return mPy;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取Z坐标值
//////////////////////////////////////////////////////////////////////////
float Point::GetZ(){
	return mPz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取点所在的三角面片
//@return	所在的三角面片的索引
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
int Point::GetTrinum(){
	return trinum;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取点的索引
//@return	点的索引值
//////////////////////////////////////////////////////////////////////////
int Point::GetIndex(){
	return index;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置点的X坐标值
//@param	px:点的新的X坐标值
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Point::SetX(float px){
	mPx = px;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置当前点的Y坐标
//@param	py:新的Y坐标
//////////////////////////////////////////////////////////////////////////
void Point::SetY(float py){
	mPy = py;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置当前点的Z坐标
//@param	pz:点的Z坐标
//////////////////////////////////////////////////////////////////////////
void Point::SetZ(float pz){
	mPz = pz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置点所在的三角面片
//@param	num:新的三角面片编号
//////////////////////////////////////////////////////////////////////////
void Point::SetTrinum(int num){
	trinum = num;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置点的索引值
//@param	i:新的索引值
//////////////////////////////////////////////////////////////////////////
void Point::SetIndex(int i){
	index = i;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取点的法向量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Normal Point::GetNormal(){
	return mNormal;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取当前点的主方向向量1
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Normal Point::GetPrincipal1(){
	return mPrincipal1;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取当前点的主方向向量2
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Normal Point::GetPrincipal2(){
	return mPrincipal2;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置点的法向量
//@param	n:新的法向量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Point::SetNormal(Normal n){
	mNormal = n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置点的主方向向量1
//@param	n:新的主方向向量1
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Point::SetPrincipal1(Normal n){
	mPrincipal1 = n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置主方向向量2
//@param	n:新的主方向向量2
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Point::SetPrincipal2(Normal n){
	mPrincipal2 = n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	法向量构造函数
//////////////////////////////////////////////////////////////////////////
Normal::Normal(){
	mNx = mNy = mNz = 0.0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	法向量构造函数
//@param	nx,ny,nz:法向量的X,Y,Z分量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Normal::Normal(float nx,float ny,float nz){
	mNx = nx;
	mNy = ny;
	mNz = nz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	法向量构造函数，计算三个顶点构成的三角形的法向量
//@param	v1,v2,v3:构成三角形的三个顶点
//////////////////////////////////////////////////////////////////////////
Normal::Normal(Vertex v1, Vertex v2, Vertex v3){
	Vertex u = Vertex(v2.GetX()-v1.GetX(),v2.GetY()-v1.GetY(),v2.GetZ()-v1.GetZ());
	Vertex v = Vertex(v3.GetX()-v1.GetX(),v3.GetY()-v1.GetY(),v3.GetZ()-v1.GetZ());
	float nx ,ny ,nz;
	mNx = u.GetY() * v.GetZ() - u.GetZ() * v.GetY();
	mNy = u.GetZ() * v.GetX() - u.GetX() * v.GetZ();
	mNz = u.GetX() * v.GetY() - u.GetY() * v.GetX();
}

//////////////////////////////////////////////////////////////////////////
//@intro	初始化法向量为零向量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Normal::Init(){
	mNx = mNy = mNz = 0.0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	单位化法向量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Normal::Normalize(){
	float length = sqrt(mNx*mNx+mNy*mNy +mNz*mNz);
	mNx = mNx/length;
	mNy = mNy/length;
	mNz = mNz/length;
}

//////////////////////////////////////////////////////////////////////////
//@intro	计算向量长度
//@return	向量长度
//////////////////////////////////////////////////////////////////////////
float Normal::GetLength(){
	return sqrt(mNx*mNx+mNy*mNy +mNz*mNz);
}

//////////////////////////////////////////////////////////////////////////
//@intro	重载赋值运算符
//@param	n:用来给当前向量赋值的向量
//////////////////////////////////////////////////////////////////////////
Normal& Normal::operator=(const Normal n){
	mNx = n.mNx;
	mNy = n.mNy;
	mNz = n.mNz;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//@intro	重载*运算符，将当前Vertex乘以系数
//@param	f:被乘的系数
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Normal& Normal::operator*(float f){
	mNx *= f;
	mNy *= f; 
	mNz *= f;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//@intro	重载赋值运算符
//@param	n:所加的法向量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Normal&  Normal::operator+(Normal n){
	mNx += n.mNx;
	mNy += n.mNy;
	mNz += n.mNz;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//@intro	重载-运算符
//@param	n:所减去的向量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Normal& Normal::operator-(Normal n){
	mNx -= n.mNx;
	mNy -= n.mNy;
	mNz -= n.mNz;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//@intro	法向量叉乘操作
//@param	n:所叉乘的法向量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
Normal Normal::Cross(Normal n){
	float nx = mNy* n.GetZ()- mNz*n.GetY();
	float ny = mNz*n.GetX()- mNx*n.GetZ();
	float nz = mNx*n.GetY() - mNy*n.GetX();
	return Normal(nx,ny,nz);
}

//////////////////////////////////////////////////////////////////////////
//@intro	法向量点乘运算
//@param	tempNormal:被点乘的法向量
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float Normal::DotProduct(Normal tempNormal){
	return mNx*tempNormal.GetX()+ mNy* tempNormal.GetY() + mNz * tempNormal.GetZ();
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置法向量的值
//@param	_x,_y,_z:法向量新的X,Y,Z坐标值
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
void Normal::Set(float _x,float _y,float _z){
	mNx = _x;
	mNy = _y;
	mNz = _z;
	Normalize();
}

//////////////////////////////////////////////////////////////////////////
//@intro	将法向量转换为数组
//@return	转换后得到的数组
//  [5/10/2016 zhangbo]
//////////////////////////////////////////////////////////////////////////
float* Normal::ToFloat(){
	float* n = new float[3];
	n[0] = mNx;n[1] = mNy;n[2] = mNz;
	return n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取法向量的X分量
//////////////////////////////////////////////////////////////////////////
float Normal::GetX(){
	return mNx;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取法向量的Y分量
//////////////////////////////////////////////////////////////////////////
float Normal::GetY(){
	return mNy;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取法向量的Z分量
//////////////////////////////////////////////////////////////////////////
float Normal::GetZ(){
	return mNz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置法向量的X分量
//@param	vx:新的X分量
//////////////////////////////////////////////////////////////////////////
void Normal::SetX(float vx){
	mNx = vx;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置法向量的Y分量
//@param	vy:法向量新的Y分量
//////////////////////////////////////////////////////////////////////////
void Normal::SetY(float vy){
	mNy = vy;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置法向量的Z分量
//////////////////////////////////////////////////////////////////////////
void Normal::SetZ(float vz){
	mNz = vz;
}

//////////////////////////////////////////////////////////////////////////
//@intro	用数组设置法向量的值
//@param	v：用于设置法向量的数组
//////////////////////////////////////////////////////////////////////////
void Normal::Set(float* v){
	mNx = v[0];
	mNy = v[1];
	mNz = v[2];
}

//////////////////////////////////////////////////////////////////////////
//@intro	纹理的默认构造函数
//////////////////////////////////////////////////////////////////////////
Texture::Texture(){
	mTx = mTy = 0.0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	构造函数
//@param	tx,ty:纹理的X,Y坐标
//////////////////////////////////////////////////////////////////////////
Texture::Texture(float tx, float ty){
	mTx = tx;
	mTy = ty;
}

//////////////////////////////////////////////////////////////////////////
//@intro	初始化纹理坐标
//////////////////////////////////////////////////////////////////////////
void Texture::Init(){
	mTx = mTy = 0.0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	重载+=运算符
//@param	tex:所加的纹理坐标
//////////////////////////////////////////////////////////////////////////
Texture& Texture::operator+=(const Texture tex){
	mTx += tex.mTx;
	mTy += tex.mTy;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//@intro	将当前纹理转换为数组
//@return	转换得到的数组
//////////////////////////////////////////////////////////////////////////
float* Texture::ToFloat(){
	static float n[2];
	n[0] = mTx;n[1] = mTy;
	return n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取纹理的X分量
//////////////////////////////////////////////////////////////////////////
float Texture::GetX(){
	return mTx;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取纹理的Y分量
//////////////////////////////////////////////////////////////////////////
float Texture::GetY(){
	return mTy;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置纹理的X分量
//@param	tx:纹理新的X分量
//////////////////////////////////////////////////////////////////////////
void Texture::SetX(float tx){
	mTx = tx;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置纹理的Y分量
//@param	ty:纹理新的Y分量
//////////////////////////////////////////////////////////////////////////
void Texture::SetY(float ty){
	mTy = ty;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置纹理值
//@param	tx：纹理新的X分量
//@param	ty：纹理新的Y分量
//////////////////////////////////////////////////////////////////////////
void Texture::Set(float tx,float ty){
	mTx = tx;
	mTy = ty;
}

//////////////////////////////////////////////////////////////////////////
//@intro	用数组设置纹理的值
//@param	用于设置纹理坐标的数组
//////////////////////////////////////////////////////////////////////////
void Texture::Set(float* t){
	mTx = t[0];
	mTy = t[1];
}

//////////////////////////////////////////////////////////////////////////
//@intro	三角面片构造函数
//@param	v:顶点索引数组
//@param	n:顶点法向量索引数组
//@param	t:顶点纹理索引数组
//@param	f:三角面片法向量索引值
//////////////////////////////////////////////////////////////////////////
Triangle::Triangle(int v[3],int n[3],int t[3],int f){
	mVindices[0] = v[0]; mVindices[1] = v[1]; mVindices[2] = v[2];
	mNindices[0] = n[0]; mNindices[1] = n[1]; mNindices[2] = n[2];
	mTindices[0] = t[0]; mTindices[1] = t[1]; mTindices[2] = t[2];
	mFindex = f;
}

//////////////////////////////////////////////////////////////////////////
//@intro	默认构造函数
//////////////////////////////////////////////////////////////////////////
Triangle::Triangle(){
	mVindices[0] = 0; mVindices[1] = 0; mVindices[2] = 0;
	mNindices[0] = 0; mNindices[1] = 0; mNindices[2] = 0;
	mTindices[0] = 0; mTindices[1] = 0; mTindices[2] = 0;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片的顶点索引
//////////////////////////////////////////////////////////////////////////
int* Triangle::GetVindices(){
	return mVindices;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片的顶点法向量索引
//////////////////////////////////////////////////////////////////////////
int* Triangle::GetNindices(){
	return mNindices;
}

///////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片顶点纹理索引
//////////////////////////////////////////////////////////////////////////
int* Triangle::GetTindices(){
	return mTindices;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片法向量索引
//////////////////////////////////////////////////////////////////////////
int Triangle::GetFindex(){
	return mFindex;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置三角面片顶点索引数组
//@param	v:三家面片顶点新的数组
//////////////////////////////////////////////////////////////////////////
void Triangle::SetVindices(int* v){
	mVindices[0] = v[0];
	mVindices[1] = v[1];
	mVindices[2] = v[2];
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置三角面片顶点法向量索引
//@param	n:新的顶点法向量索引数组
//////////////////////////////////////////////////////////////////////////
void Triangle::SetNindices(int* n){
	mNindices[0] = n[0];
	mNindices[1] = n[1];
	mNindices[2] = n[2];
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置三角面片顶点纹理索引
//@param	t:新的三角面片纹理索引数组
//////////////////////////////////////////////////////////////////////////
void Triangle::SetTindices(int* t){
	mTindices[0] = t[0];
	mTindices[1] = t[1]; 
	mTindices[2] = t[2];
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置三角面片法向量索引
//@param	f：三角面片新的法向量索引
//////////////////////////////////////////////////////////////////////////
void Triangle::SetFindex(int f){mFindex = f;}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片顶点A
//////////////////////////////////////////////////////////////////////////
Vertex Face::GetVertexA(){
	return mVertexA;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片顶点B
//////////////////////////////////////////////////////////////////////////
Vertex Face::GetVertexB(){
	return mVertexB;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片顶点C 
//////////////////////////////////////////////////////////////////////////
Vertex Face::GetVertexC(){
	return mVertexC;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片顶点A的纹理
//////////////////////////////////////////////////////////////////////////
Texture Face::GetTextureA(){
	return mTextureA;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片顶点B的
//////////////////////////////////////////////////////////////////////////
Texture Face::GetTextureB(){
	return mTextureB;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片顶点C的纹理
//////////////////////////////////////////////////////////////////////////
Texture Face::GetTextureC(){
	return mTextureC;
}

//////////////////////////////////////////////////////////////////////////
//@intro	三角面片默认构造函数
//////////////////////////////////////////////////////////////////////////
Face::Face(){
	mVertexA = Vertex(0,0,0);
	mVertexB = Vertex(0,0,0);
	mVertexC = Vertex(0,0,0);
	mTextureA = Texture(0,0);
	mTextureB = Texture(0,0);
	mTextureC = Texture(0,0);
	mGroupNum = 0;
	mIsPositive = true;
}

//////////////////////////////////////////////////////////////////////////
//@intro	三角面片构造函数
//@param	a,b,c：三角面片的三个顶点
//@param	texture_a,texture_b,texture_c:三角面片三个顶点的纹理
//////////////////////////////////////////////////////////////////////////
Face::Face(Vertex a,Vertex b,Vertex c,Texture texture_a,Texture texture_b,Texture texture_c){
	mVertexA = a;
	mVertexB = b;
	mVertexC = c;
	mTextureA = texture_a;
	mTextureB = texture_b;
	mTextureC = texture_c;
	mGroupNum = 0;
	mIsPositive = true;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置三角面片所属的Group
//@param	num：新的Group索引
//////////////////////////////////////////////////////////////////////////
void Face::SetGroup(int num){
	mGroupNum = num;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片所属的Group
//////////////////////////////////////////////////////////////////////////
int Face::GetGroup(){
	return mGroupNum;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置三角面片是否位于yoz平面右侧
//@param	p:新的属性值
//////////////////////////////////////////////////////////////////////////
void Face::SetPositive(bool p){
	mIsPositive = p;
}

//////////////////////////////////////////////////////////////////////////
//@intro	判断三角面片是否位于yoz平面右侧的属性
//////////////////////////////////////////////////////////////////////////
bool Face::GetPositive(){
	return mIsPositive;
}

//////////////////////////////////////////////////////////////////////////
//@intro	材质构造函数
//@param	n:材质名称
//@param	d:漫反射参数
//@param	a：环境光参数
//@param	s:镜面反射参数
//@param	e:发射光参数
//@param	sh:镜面反射参数
//@param	file: 纹理映射文件名称
//////////////////////////////////////////////////////////////////////////
Material::Material(char* n, float d[4],float a[4],float s[4],float e[4],float sh,char* file){
	m_name = n;
	mDiffuse[0] = d[0];mDiffuse[1] = d[1];mDiffuse[2] = d[2];mDiffuse[3] = d[3];
	mAmbient[0] = a[0];mAmbient[1] = a[1];mAmbient[2] = a[2];mAmbient[3] = a[3];
	mSpecular[0] = s[0];mSpecular[1] = s[1];mSpecular[2] = s[2];mSpecular[3] = s[3];
	mEmmissive[0] = e[0];mEmmissive[1] = e[1];mEmmissive[2] = e[2];mDiffuse[3] = e[3];
	mShininess = sh;
	map_file = file;
}

//////////////////////////////////////////////////////////////////////////
//@intro	构造函数
//@param	n:材质名称
//////////////////////////////////////////////////////////////////////////
Material::Material(char* n){
	m_name = n;
	mDiffuse[0] = 0;mDiffuse[1] = 0;mDiffuse[2] = 0;mDiffuse[3] = 0;
	mAmbient[0] = 0;mAmbient[1] = 0;mAmbient[2] = 0;mAmbient[3] = 0;
	mSpecular[0] = 0;mSpecular[1] = 0;mSpecular[2] = 0;mSpecular[3] = 0;
	mEmmissive[0] = 0;mEmmissive[1] = 0;mEmmissive[2] = 0;mDiffuse[3] = 0;
	mShininess = 0;
	map_file = "";
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置漫反射参数
//@param	d:新的漫反射参数
//////////////////////////////////////////////////////////////////////////
void Material::SetDiffuse(float d[4]){
	mDiffuse[0] = d[0];
	mDiffuse[1] = d[1];
	mDiffuse[2] = d[2];
	mDiffuse[3] = d[3];
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置环境光参数
//@param	a:新的环境光参数
//////////////////////////////////////////////////////////////////////////
void Material::SetAmbient(float a[4]){
	mAmbient[0] = a[0];
	mAmbient[1] = a[1];
	mAmbient[2] = a[2];
	mAmbient[3] = a[3];
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置镜面反射参数
//@param	s:新的镜面反射参数
//////////////////////////////////////////////////////////////////////////
void Material::SetSpecular(float s[4]){
	mSpecular[0] = s[0];
	mSpecular[1] = s[1];
	mSpecular[2] = s[2];
	mSpecular[3] = s[3];
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置材质名称
//@param	n:新的财智名称
//////////////////////////////////////////////////////////////////////////
void Material::SetName(char* n){
	m_name = n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置镜面反射参数
//@param	sh：新的镜面反射参数
//////////////////////////////////////////////////////////////////////////
void Material::SetShiness(float sh){
	mShininess = sh;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置纹理映射文件名称
//@param	mfile：新的纹理映射文件名称
//////////////////////////////////////////////////////////////////////////
void Material::SetMapfile(char* mfile){
	map_file = mfile;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取漫反射参数
//////////////////////////////////////////////////////////////////////////
float* Material::GetDiffuse(){
	return mDiffuse;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取环境光参数
//////////////////////////////////////////////////////////////////////////
float* Material::GetAmbient(){
	return mAmbient;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取镜面反射参数
//////////////////////////////////////////////////////////////////////////
float* Material::GetSpecular(){
	return mSpecular;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取材质名称
//////////////////////////////////////////////////////////////////////////
char* Material::GetName(){
	return m_name;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取镜面反射参数
//////////////////////////////////////////////////////////////////////////
float Material::GetShiness(){
	return mShininess;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取纹理映射文件名称
//////////////////////////////////////////////////////////////////////////
char* Material::GetMapfile(){
	return map_file;
}

//////////////////////////////////////////////////////////////////////////
//@intro	Group构造函数
//@param	n:Group名称
//@param	m:材质名称
//////////////////////////////////////////////////////////////////////////
Group::Group(char* n,int m){
	mName = n, 
	mMaterialno = m;
}

//////////////////////////////////////////////////////////////////////////
//@intro	默认构造函数
//////////////////////////////////////////////////////////////////////////
Group::Group(){
	mName = "";
}

//////////////////////////////////////////////////////////////////////////
//@intro	构造函数
//@param	gname:Group名称
//////////////////////////////////////////////////////////////////////////
Group::Group(char* gname){

}

//////////////////////////////////////////////////////////////////////////
//@intro	获取Group名称
//////////////////////////////////////////////////////////////////////////
char* Group::GetName(){
	return mName;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取三角面片集合
//////////////////////////////////////////////////////////////////////////
vector<int> Group::GetTriangles(){
	return mTriangles;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取对应的材质编号
//////////////////////////////////////////////////////////////////////////
int Group::GetMaterialno(){
	return mMaterialno;
}

//////////////////////////////////////////////////////////////////////////
//@intro	获取Group名称
//////////////////////////////////////////////////////////////////////////
void Group::SetName(char* n){
	mName =  n;
}

//////////////////////////////////////////////////////////////////////////
//@intro	设置对应的材质编号
//@param	m:新的材质编号
//////////////////////////////////////////////////////////////////////////
void Group::SetMaterialno(int m){
	mMaterialno = m;
}

//////////////////////////////////////////////////////////////////////////
//@intro	添加三角面片
//@param	t:添加的三角面片索引
//////////////////////////////////////////////////////////////////////////
void Group::AddTriangle(int t){
	mTriangles.push_back(t);
}


//////////////////////////////////////////////////////////////////////////
//@intro	判断点P是否在点A,B,C的内侧 
//@param	A,B,C:三角形的三个顶点
//@param	P:被判断的点
//////////////////////////////////////////////////////////////////////////
bool SameSide(Vertex A, Vertex B, Vertex C, Point P){
	bool sameside;
	Vertex AB = Vertex(B.GetX() - A.GetX(), B.GetY() - A.GetY(), B.GetZ() - A.GetZ());
	Vertex AC = Vertex(C.GetX() - A.GetX(), C.GetY() - A.GetY(), C.GetZ() - A.GetZ());
	Vertex AP = Vertex(P.GetX() - A.GetX(), P.GetY() - A.GetY(), P.GetZ() - A.GetZ());

	Vertex v1 = Vertex(AB.GetY()*AC.GetZ() - AB.GetZ()*AC.GetY(),
		AB.GetZ()*AC.GetX() - AB.GetX()*AC.GetZ(),
		AB.GetX()*AC.GetY() - AB.GetY()*AC.GetX());
	Vertex v2 = Vertex(AB.GetY()*AP.GetZ() - AB.GetZ()*AP.GetY(),
		AB.GetZ()*AP.GetX() - AB.GetX()*AP.GetZ(),
		AB.GetX()*AP.GetY() - AB.GetY()*AP.GetX());
	sameside = v1.Dot(v2) >= 0?true:false;
	return sameside;
}

//////////////////////////////////////////////////////////////////////////
//@intro	判断点vertex是否在顶点为A,B,C的三角形内部
//@param	A,B,C:三角形的三个顶点
//@param	point:被判断的点
//////////////////////////////////////////////////////////////////////////
bool IsInTriangle(Vertex A, Vertex B, Vertex C, Point point){
	return SameSide(A, B, C, point) && SameSide(B, C, A, point) && SameSide(C, A, B, point);
}

//////////////////////////////////////////////////////////////////////////
//@intro	判断两个三角面片是否相邻   
//@param	triangle1,triangle2:进行判断的两个三角面片
//////////////////////////////////////////////////////////////////////////
bool IsNeighborTri(Triangle triangle1,Triangle triangle2){
	int* vindices1 = triangle1.GetVindices();
	int* vindices2 = triangle2.GetVindices();

	for(int i = 0;i < 4;i++){
		for(int j = 0;j < 4;j++){
			if(vindices1[i]== vindices2[j]){
				return true;
			}
		}
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////
//@intro	计算两个顶点之间距离                      
//@param	v1,v2:进行计算距离的两个顶点
//////////////////////////////////////////////////////////////////////////
float Distance(Vertex v1, Vertex v2){
	return sqrt((v1.GetX() - v2.GetX())*(v1.GetX() - v2.GetX()) +
		(v1.GetY() - v2.GetY())*(v1.GetY() - v2.GetY()) +
		(v1.GetZ() - v2.GetZ())*(v1.GetZ() - v2.GetZ()));
}

//////////////////////////////////////////////////////////////////////////
//@intro	计算顶点与样本点之间的距离  
//@param	v1:三角面片的顶点
//@param	p2:三维空间内的点
//////////////////////////////////////////////////////////////////////////
float Distance(Vertex v1, Point p2){
	return sqrt((v1.GetX() - p2.GetX())*(v1.GetX() - p2.GetX()) +
		(v1.GetY() - p2.GetY())*(v1.GetY() - p2.GetY()) +
		(v1.GetZ() - p2.GetZ())*(v1.GetZ() - p2.GetZ()));
}

//////////////////////////////////////////////////////////////////////////
//@intro	计算两个样本点之间的距离 
//@intro	p1,p2:三维空间内的两个点
//////////////////////////////////////////////////////////////////////////
float Distance(Point p1, Point p2){
	return sqrt((p1.GetX() - p2.GetX())*(p1.GetX() - p2.GetX()) +
		(p1.GetY() - p2.GetY())*(p1.GetY() - p2.GetY()) +
		(p1.GetZ() - p2.GetZ())*(p1.GetZ() - p2.GetZ()));
}

//////////////////////////////////////////////////////////////////////////
//@intro	计算三个顶点构成的三角形的面积                                                                      
//@param	v1,v2,v3:三角形的三个顶点
//////////////////////////////////////////////////////////////////////////
float TriangleArea(Vertex v1,Vertex v2,Vertex v3){
	float ab[3],ac[3],crossprd[3];

	ab[0] = v2.GetX()- v1.GetX();
	ab[1] = v2.GetY()- v1.GetY();
	ab[2] = v2.GetZ() - v1.GetZ();

	ac[0] = v3.GetX() - v1.GetX();
	ac[1] = v3.GetY() - v1.GetY();
	ac[2] = v3.GetZ() - v1.GetZ();

	crossprd[0] = ab[1]*ac[2]-ab[2]*ac[1];
	crossprd[1] = ab[0]*ac[2]- ab[2]*ac[0];
	crossprd[2] = ab[0]*ac[1]- ab[1]*ac[0];
	return 0.5*sqrt(crossprd[0]*crossprd[0]+crossprd[1]*crossprd[1]+crossprd[2]*crossprd[2]);
}

//////////////////////////////////////////////////////////////////////////
//@intro	判断顶点是否位于平面上方，位于上方则返回1，下方则返回-1，否则返回0
//@param	vertexA:要判断位置的顶点
//@param	abcd,centerPoint:平面的参数
//@return	如果顶点位于平面上方则返回true,否则返回false
//////////////////////////////////////////////////////////////////////////
int IsVertexUpperPlane(Vertex vertexA, float* abcd, VECTOR3 centerPoint){
	Normal plane2Vertex = Normal(vertexA.GetX() - centerPoint.vec[0],vertexA.GetY() - centerPoint.vec[1],vertexA.GetZ() - centerPoint.vec[2]);
	Normal planeNormal = Normal(abcd[0],abcd[1],abcd[2]);
	float dotProduct = plane2Vertex.DotProduct(planeNormal);	//根据点乘的大小判断顶点位于平面的上方或者下方
	if(dotProduct > 0){
		return 1;
	}
	else if(dotProduct < 0){
		return -1;
	}
	else if(dotProduct == 0){
		return 0;
	}
	return 0;
}


//////////////////////////////////////////////////////////////////////////
//@intro	判断三角面片是否位于平面上方，位于平面上方则返回1，位于平面下方则返回-1
//@param	face：三角面片
//@param	abcd,centerPoint:平面参数
//@return	三角面片位于平面上方则返回1，位于平面下方则返回-1,否则返回0
//////////////////////////////////////////////////////////////////////////
int IsFaceUpperPlane(Face face,float* abcd,VECTOR3 centerPoint){
	Vertex vertexA = face.GetVertexA();
	Vertex vertexB = face.GetVertexB();
	Vertex vertexC = face.GetVertexC();
	Normal faceNormal = Normal(vertexA,vertexB,vertexC);

	float dis[3];
	int upper[3];
	dis[0] = abcd[0] * vertexA.GetX() + abcd[1] * vertexA.GetY() + abcd[2] * vertexA.GetZ() + abcd[3];
	dis[1] = abcd[0] * vertexB.GetX() + abcd[1] * vertexB.GetY() + abcd[2] * vertexB.GetZ() + abcd[3];
	dis[2] = abcd[0] * vertexC.GetX() + abcd[1] * vertexC.GetY() + abcd[2] * vertexC.GetZ() + abcd[3];

	//判断三角面片的三个顶点是否位于平面上方
	upper[0] = IsVertexUpperPlane(vertexA,abcd,centerPoint);
	upper[1] = IsVertexUpperPlane(vertexB,abcd,centerPoint);
	upper[2] = IsVertexUpperPlane(vertexC,abcd,centerPoint);

	//三角面片位于平面上方
	//三个顶点都位于平面上方||两个顶点位于平面上方,一个顶点位于平面上||一个顶点位于平面上方，两个顶点位于平面上
	if( (upper[0] > 0 && upper[1] > 0 && upper[2] > 0)||
		(upper[0] > 0 && upper[1] > 0 && fabs(dis[2]) < 1.0e-8) || (upper[0] > 0 && fabs(dis[1]) < 1.0e-8 && upper[2] > 0 ) || (fabs(dis[0]) < 1.0e-8 &&upper[1] > 0 &&  upper[2] > 0 )||
		(upper[0] > 0 && fabs(dis[1]) < 1.0e-8 && fabs(dis[2]) < 1.0e-8)||( fabs(dis[0]) < 1.0e-8 && upper[1] > 0 &&fabs(dis[2]) < 1.0e-8)||( fabs(dis[0]) < 1.0e-8 &&fabs(dis[1]) < 1.0e-8&& upper[2] > 0 )){
			return 1;
	}
	//三角面片位于平面下方
	//三个顶点都位于平面下方||两个顶点位于平面下方,一个顶点位于平面上||一个顶点位于平面下方，两个顶点位于平面上
	else if( (upper[0] < 0 && upper[1] < 0 && upper[2] < 0)||
		(upper[0] < 0 && upper[1] < 0 && fabs(dis[2]) < 1.0e-8) || (upper[0] < 0 && fabs(dis[1]) < 1.0e-8 && upper[2] < 0 ) || (fabs(dis[0]) < 1.0e-8 &&upper[1] < 0 &&  upper[2] < 0 )||
		(upper[0] < 0 && fabs(dis[1]) < 1.0e-8 && fabs(dis[2]) < 1.0e-8)||( fabs(dis[0]) < 1.0e-8 && upper[1] < 0 &&fabs(dis[2]) < 1.0e-8)||( fabs(dis[0]) < 1.0e-8 &&fabs(dis[1]) < 1.0e-8&& upper[2] < 0 )){
			return -1;
	}
	return 1;
}
